<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圖片處理：即時可調節的黑白線稿轉換器</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; max-width: 800px; margin: 0 auto; padding: 20px; }
        #canvasContainer { display: inline-block; margin-top: 20px; border: 1px solid #ddd; }
        .controls { margin-top: 20px; text-align: left; }
        .control { margin-bottom: 10px; }
        label { display: inline-block; width: 200px; }
        input[type="range"] { width: 300px; }
        button { margin-top: 20px; padding: 10px 20px; font-size: 16px; }
    </style>
</head>
<body>
    <h1>圖片處理：即時可調節的黑白線稿轉換器</h1>
    <p>請將圖片貼上到下方區域</p>
    <div id="canvasContainer">
        <canvas id="canvas" width="500" height="500"></canvas>
    </div>
    <div class="controls">
        <div class="control">
            <label for="lowThreshold">低閾值：</label>
            <input type="range" id="lowThreshold" min="0" max="127" value="20">
            <span id="lowThresholdValue">20</span>
        </div>
        <div class="control">
            <label for="highThreshold">高閾值：</label>
            <input type="range" id="highThreshold" min="0" max="255" value="60">
            <span id="highThresholdValue">60</span>
        </div>
        <div class="control">
            <label for="blurRadius">模糊半徑：</label>
            <input type="range" id="blurRadius" min="0" max="5" value="1" step="0.1">
            <span id="blurRadiusValue">1</span>
        </div>
    </div>
    <button id="downloadButton">下載圖片</button>
    <button id="copyButton">複製到剪貼簿</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');
        let originalImageData;

        // 控制項
        const lowThresholdInput = document.getElementById('lowThreshold');
        const highThresholdInput = document.getElementById('highThreshold');
        const blurRadiusInput = document.getElementById('blurRadius');
        const downloadButton = document.getElementById('downloadButton');
        const copyButton = document.getElementById('copyButton');

        // 更新顯示的值和即時處理圖像
        function updateValueAndProcess(input, valueSpan) {
            document.getElementById(valueSpan).textContent = input.value;
            processImage();
        }

        lowThresholdInput.oninput = () => updateValueAndProcess(lowThresholdInput, 'lowThresholdValue');
        highThresholdInput.oninput = () => updateValueAndProcess(highThresholdInput, 'highThresholdValue');
        blurRadiusInput.oninput = () => updateValueAndProcess(blurRadiusInput, 'blurRadiusValue');

        downloadButton.onclick = downloadImage;
        copyButton.onclick = copyToClipboard;

        document.addEventListener('paste', function(event) {
            const items = event.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    const url = URL.createObjectURL(blob);
                    const img = new Image();
                    img.onload = function() {
                        resizeCanvas(img.width, img.height);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        processImage();
                    };
                    img.src = url;
                }
            }
        });

        function resizeCanvas(imgWidth, imgHeight) {
            const maxWidth = 800;
            const maxHeight = 600;
            let newWidth = imgWidth;
            let newHeight = imgHeight;

            if (newWidth > maxWidth) {
                newHeight *= maxWidth / newWidth;
                newWidth = maxWidth;
            }
            if (newHeight > maxHeight) {
                newWidth *= maxHeight / newHeight;
                newHeight = maxHeight;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;
            container.style.width = newWidth + 'px';
            container.style.height = newHeight + 'px';
        }

        function processImage() {
            if (!originalImageData) return;

            const lowThreshold = parseInt(lowThresholdInput.value);
            const highThreshold = parseInt(highThresholdInput.value);
            const blurRadius = parseFloat(blurRadiusInput.value);

            const imageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );

            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // 轉換為灰度
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.3 * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];
                data[i] = data[i + 1] = data[i + 2] = gray;
            }

            // 應用Canny邊緣檢測
            const edges = cannyEdgeDetection(imageData, blurRadius, lowThreshold, highThreshold);

            // 繪製邊緣
            for (let i = 0; i < data.length; i += 4) {
                const color = edges[i / 4] > 0 ? 0 : 255;
                data[i] = data[i + 1] = data[i + 2] = color;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function cannyEdgeDetection(imageData, blurRadius, lowThreshold, highThreshold) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const edges = new Uint8ClampedArray(width * height);

            // 高斯模糊
            const blurred = gaussianBlur(data, width, height, blurRadius);

            // 計算梯度
            const [gradientMagnitude, gradientDirection] = computeGradients(blurred, width, height);

            // 非最大抑制
            const suppressed = nonMaximumSuppression(gradientMagnitude, gradientDirection, width, height);

            // 雙閾值處理和邊緣追蹤
            hysteresisThresholding(suppressed, edges, width, height, lowThreshold, highThreshold);

            return edges;
        }

        function gaussianBlur(data, width, height, radius) {
            const size = Math.max(3, 2 * Math.floor(radius) + 1);
            const sigma = radius / 3;
            const kernel = new Array(size).fill(0).map(() => new Array(size).fill(0));
            let sum = 0;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const dx = x - (size - 1) / 2;
                    const dy = y - (size - 1) / 2;
                    const value = Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
                    kernel[y][x] = value;
                    sum += value;
                }
            }

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    kernel[y][x] /= sum;
                }
            }

            const blurred = new Uint8ClampedArray(data.length);
            const halfSize = Math.floor(size / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    for (let ky = 0; ky < size; ky++) {
                        for (let kx = 0; kx < size; kx++) {
                            const ix = Math.min(Math.max(x + kx - halfSize, 0), width - 1);
                            const iy = Math.min(Math.max(y + ky - halfSize, 0), height - 1);
                            const idx = (iy * width + ix) * 4;
                            sum += data[idx] * kernel[ky][kx];
                        }
                    }
                    const idx = (y * width + x) * 4;
                    blurred[idx] = blurred[idx + 1] = blurred[idx + 2] = sum;
                    blurred[idx + 3] = 255;
                }
            }
            return blurred;
        }

        function computeGradients(data, width, height) {
            const magnitude = new Uint8ClampedArray(width * height);
            const direction = new Uint8ClampedArray(width * height);
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const gx = data[idx - 4] - data[idx + 4];
                    const gy = data[idx - width * 4] - data[idx + width * 4];
                    magnitude[y * width + x] = Math.sqrt(gx * gx + gy * gy);
                    direction[y * width + x] = Math.atan2(gy, gx) * (4 / Math.PI) + 4;
                }
            }
            return [magnitude, direction];
        }

        function nonMaximumSuppression(magnitude, direction, width, height) {
            const suppressed = new Uint8ClampedArray(width * height);
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const mag = magnitude[idx];
                    const dir = direction[idx] & 7;
                    let prev, next;

                    switch (dir) {
                        case 0: case 4: prev = magnitude[idx - 1]; next = magnitude[idx + 1]; break;
                        case 1: case 5: prev = magnitude[idx - width - 1]; next = magnitude[idx + width + 1]; break;
                        case 2: case 6: prev = magnitude[idx - width]; next = magnitude[idx + width]; break;
                        case 3: case 7: prev = magnitude[idx - width + 1]; next = magnitude[idx + width - 1]; break;
                    }

                    suppressed[idx] = (mag >= prev && mag >= next) ? mag : 0;
                }
            }
            return suppressed;
        }

        function hysteresisThresholding(suppressed, edges, width, height, lowThreshold, highThreshold) {
            for (let i = 0; i < suppressed.length; i++) {
                if (suppressed[i] >= highThreshold) {
                    edges[i] = 255;
                } else if (suppressed[i] >= lowThreshold) {
                    const x = i % width;
                    const y = Math.floor(i / width);
                    if (isConnectedToStrongEdge(suppressed, x, y, width, height, highThreshold)) {
                        edges[i] = 255;
                    }
                }
            }
        }

        function isConnectedToStrongEdge(suppressed, x, y, width, height, threshold) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        if (suppressed[ny * width + nx] >= threshold) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'processed-image.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function copyToClipboard() {
            canvas.toBlob(function(blob) {
                const item = new ClipboardItem({ "image/png": blob });
                navigator.clipboard.write([item]).then(function() {
                    alert("圖片已複製到剪貼簿");
                }, function(err) {
                    console.error("無法複製圖片: ", err);
                });
            });
        }
    </script>
</body>
</html>
